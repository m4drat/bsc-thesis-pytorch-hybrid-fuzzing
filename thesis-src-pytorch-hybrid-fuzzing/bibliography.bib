@misc{chromium-project-memory-safety,
  howpublished = {\url{https://www.chromium.org/Home/chromium-security/memory-safety/}},
  title        = {Chromium project memory safety report},
  note         = {Accessed: 2023-02-12}
}

@misc{android-project-memory-safety,
  howpublished = {\url{https://source.android.com/docs/security/test/memory-safety}},
  title        = {Android project memory safety report},
  note         = {Accessed: 2023-02-13}
}

@misc{what-science-can-tell-us-about-c-and-c++-security,
  howpublished = {\url{https://alexgaynor.net/2020/may/27/science-on-memory-unsafety-and-security/}},
  title        = {What science can tell us about C and C++'s security},
  note         = {Accessed: 2023-03-14}
}

@misc{pytorch-pr-94300-size-check-unpickler,
  howpublished = {\url{https://github.com/pytorch/pytorch/pull/94300}},
  title        = {PyTorch: pull-request "Add size check before calling stack_.at(dict_pos) in unpickler.cpp"},
  note         = {Accessed: 2023-05-01}
}

@misc{pytorch-pr-94298-emptiness-check-interpreter,
  howpublished = {\url{https://github.com/pytorch/pytorch/pull/94298}},
  title        = {PyTorch: pull-request "Add stack emptiness checks inside interpreter.cpp"},
  note         = {Accessed: 2023-05-01}
}

@misc{pytorch-pr-94297-size-check-rpc-script-call,
  howpublished = {\url{https://github.com/pytorch/pytorch/pull/94297}},
  title        = {PyTorch: pull-request "Add size check before calling .back() in rpc/script_call.cpp"},
  note         = {Accessed: 2023-05-01}
}

@misc{pytorch-pr-94295-exception-handlers-schema-type-parser,
  howpublished = {\url{https://github.com/pytorch/pytorch/pull/94295}},
  title        = {PyTorch: pull-request "Add exception handlers for stoll in jit/frontend/schema_type_parser.cpp"},
  note         = {Accessed: 2023-05-01}
}

@misc{pytorch-pr-91401-oob-checks-irparser-unpickler,
  howpublished = {\url{https://github.com/pytorch/pytorch/pull/91401}},
  title        = {PyTorch: pull-request "Add out of bounds checks inside irparser.cpp and unpickler.cpp"},
  note         = {Accessed: 2023-05-01}
}

@article{ql-object-oriented-queries-on-relational-data,
  title        = {QL: Object-oriented Queries on Relational Data},
  url          = {http://drops.dagstuhl.de/opus/volltexte/2016/6096/},
  doi          = {10.4230/LIPICS.ECOOP.2016.2},
  abstractnote = {This paper describes QL, a language for querying complex, potentially recursive data structures. QL compiles to Datalog and runs on a standard relational database, yet it provides familiar-looking object-oriented features such as classes and methods, reinterpreted in logical terms: classes are logical properties describing sets of values, subclassing is implication, and virtual calls are dispatched dynamically by considering the most specific classes containing the receiver. Furthermore, types in QL are prescriptive and actively influence program evaluation rather than just describing it. In combination, these features enable the development of concise queries based on reusable libraries, which are written in a purely declarative style, yet can be efficiently executed even on very large data sets. In particular, we have used QL to implement static analyses for various programming languages, which scale to millions of lines of code.},
  journal      = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany},
  author       = {Avgustinov, Pavel and De Moor, Oege and Jones, Michael Peyton and Schäfer, Max},
  year         = {2016},
  language     = {en}
}

@incollection{pytorch,
  title     = {PyTorch: An Imperative Style, High-Performance Deep Learning Library},
  author    = {Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and Desmaison, Alban and Kopf, Andreas and Yang, Edward and DeVito, Zachary and Raison, Martin and Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and Chintala, Soumith},
  booktitle = {Advances in Neural Information Processing Systems 32},
  pages     = {8024--8035},
  year      = {2019},
  publisher = {Curran Associates, Inc.},
  url       = {http://papers.neurips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library.pdf}
}

@inproceedings{qsym-usenix2018,
  author    = {Insu Yun and Sangho Lee and Meng Xu and Yeongjin Jang and Taesoo Kim},
  title     = {{QSYM} : A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing},
  booktitle = {27th USENIX Security Symposium (USENIX Security 18)},
  year      = {2018},
  isbn      = {978-1-939133-04-5},
  address   = {Baltimore, MD},
  pages     = {745--761},
  url       = {https://www.usenix.org/conference/usenixsecurity18/presentation/yun},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{triton-sstic2015,
  author    = {Saudel, Florent and Salwan, Jonathan},
  title     = {{{Triton}}: A Dynamic Symbolic Execution Framework},
  booktitle = {Symposium sur la s{\'{e}}curit{\'{e}} des technologies de l'information
               et des communications},
  series    = {SSTIC},
  pages     = {31--54},
  year      = {2015},
  url       = {https://triton.quarkslab.com/files/sstic2015_slide_en_saudel_salwan.pdf}
}

@inproceedings{qemu-usenix2005,
  author    = {Fabrice Bellard},
  title     = {{QEMU}, a Fast and Portable Dynamic Translator},
  booktitle = {2005 USENIX Annual Technical Conference (USENIX ATC 05)},
  year      = {2005},
  address   = {Anaheim, CA},
  url       = {https://www.usenix.org/conference/2005-usenix-annual-technical-conference/qemu-fast-and-portable-dynamic-translator},
  publisher = {USENIX Association},
  month     = apr
}

@inproceedings{unleashing-mayhem-on-binary-code,
  title     = {Unleashing Mayhem on Binary Code},
  author    = {Sang Kil Cha and Thanassis Avgerinos and Alexandre Rebert and David Brumley},
  year      = {2012},
  doi       = {10.1109/SP.2012.31},
  url       = {http://doi.ieeecomputersociety.org/10.1109/SP.2012.31},
  researchr = {https://researchr.org/publication/ChaARB12},
  cites     = {0},
  citedby   = {0},
  pages     = {380-394},
  booktitle = {IEEE Symposium on Security and Privacy, SP 2012, 21-23 May 2012, San Francisco, California, USA},
  publisher = {IEEE Computer Society},
  isbn      = {978-0-7695-4681-0}
}

@inproceedings{driller-ndss16,
  title     = {Driller: Augmenting Fuzzing Through Selective Symbolic Execution.},
  author    = {Stephens, Nick and Grosen, John and Salls, Christopher and Dutcher, Audrey and Wang, Ruoyu and Corbetta, Jacopo and Shoshitaishvili, Yan and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {NDSS},
  volume    = {16},
  pages     = {1--16},
  year      = {2016}
}

@article{10.1145/1064978.1065034,
  author     = {Luk, Chi-Keung and Cohn, Robert and Muth, Robert and Patil, Harish and Klauser, Artur and Lowney, Geoff and Wallace, Steven and Reddi, Vijay Janapa and Hazelwood, Kim},
  title      = {Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation},
  year       = {2005},
  issue_date = {June 2005},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {40},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1064978.1065034},
  doi        = {10.1145/1064978.1065034},
  abstract   = {Robust and powerful software instrumentation tools are essential for program analysis tasks such as profiling, performance evaluation, and bug detection. To meet this need, we have developed a new instrumentation system called Pin. Our goals are to provide easy-to-use, portable, transparent, and efficient instrumentation. Instrumentation tools (called Pintools) are written in C/C++ using Pin's rich API. Pin follows the model of ATOM, allowing the tool writer to analyze an application at the instruction level without the need for detailed knowledge of the underlying instruction set. The API is designed to be architecture independent whenever possible, making Pintools source compatible across different architectures. However, a Pintool can access architecture-specific details when necessary. Instrumentation with Pin is mostly transparent as the application and Pintool observe the application's original, uninstrumented behavior. Pin uses dynamic compilation to instrument executables while they are running. For efficiency, Pin uses several techniques, including inlining, register re-allocation, liveness analysis, and instruction scheduling to optimize instrumentation. This fully automated approach delivers significantly better instrumentation performance than similar tools. For example, Pin is 3.3x faster than Valgrind and 2x faster than DynamoRIO for basic-block counting. To illustrate Pin's versatility, we describe two Pintools in daily use to analyze production software. Pin is publicly available for Linux platforms on four architectures: IA32 (32-bit x86), EM64T (64-bit x86), Itanium®, and ARM. In the ten months since Pin 2 was released in July 2004, there have been over 3000 downloads from its website.},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {190–200},
  numpages   = {11},
  keywords   = {instrumentation, dynamic compilation, program analysis tools}
}

@phdthesis{dynamorio-thesis,
  author    = {Bruening, Derek L. and Amarasinghe, Saman},
  title     = {Efficient, Transparent, and Comprehensive Runtime Code Manipulation},
  year      = {2004},
  publisher = {Massachusetts Institute of Technology},
  address   = {USA},
  abstract  = {This thesis addresses the challenges of building a software system for general-purpose runtime code manipulation. Modern applications, with dynamically-loaded modules and dynamically-generated code, are assembled at runtime. While it was once feasible at compile time to observe and manipulate every instruction—which is critical for program analysis, instrumentation, trace gathering, optimization, and similar tools—it can now only be done at runtime. Existing runtime tools are successful at inserting instrumentation calls, but no general framework has been developed for fine-grained and comprehensive code observation and modification without high overheads. This thesis demonstrates the feasibility of building such a system in software. We present DynamoRIO , a fully-implemented runtime code manipulation system that supports code transformations on any part of a program, while it executes . DynamoRIO uses code caching technology to provide efficient, transparent, and comprehensive manipulation of an unmodified application running on a stock operating system and commodity hardware. DynamoRIO executes large, complex, modern applications with dynamically-loaded, generated, or even modified code. Despite the formidable obstacles inherent in the IA-32 architecture, DynamoRIO provides these capabilities efficiently, with zero to thirty percent time and memory overhead on both Windows and Linux. DynamoRIO exports an interface for building custom runtime code manipulation tools of all types. It has been used by many researchers, with several hundred downloads of our public release, and is being commercialized in a product for protection against remote security exploits, one of numerous applications of runtime code manipulation. (Copies available exclusively from MIT Libraries, Rm. 14-0551, Cambridge, MA 02139-4307. Ph. 617-253-5668; Fax 617-253-1690.)},
  note      = {AAI0807735}
}

@inproceedings{pintool-2005,
  author    = {Luk, Chi-Keung and Cohn, Robert and Muth, Robert and Patil, Harish and Klauser, Artur and Lowney, Geoff and Wallace, Steven and Reddi, Vijay Janapa and Hazelwood, Kim},
  title     = {Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation},
  year      = {2005},
  isbn      = {1595930566},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1065010.1065034},
  doi       = {10.1145/1065010.1065034},
  abstract  = {Robust and powerful software instrumentation tools are essential for program analysis tasks such as profiling, performance evaluation, and bug detection. To meet this need, we have developed a new instrumentation system called Pin. Our goals are to provide easy-to-use, portable, transparent, and efficient instrumentation. Instrumentation tools (called Pintools) are written in C/C++ using Pin's rich API. Pin follows the model of ATOM, allowing the tool writer to analyze an application at the instruction level without the need for detailed knowledge of the underlying instruction set. The API is designed to be architecture independent whenever possible, making Pintools source compatible across different architectures. However, a Pintool can access architecture-specific details when necessary. Instrumentation with Pin is mostly transparent as the application and Pintool observe the application's original, uninstrumented behavior. Pin uses dynamic compilation to instrument executables while they are running. For efficiency, Pin uses several techniques, including inlining, register re-allocation, liveness analysis, and instruction scheduling to optimize instrumentation. This fully automated approach delivers significantly better instrumentation performance than similar tools. For example, Pin is 3.3x faster than Valgrind and 2x faster than DynamoRIO for basic-block counting. To illustrate Pin's versatility, we describe two Pintools in daily use to analyze production software. Pin is publicly available for Linux platforms on four architectures: IA32 (32-bit x86), EM64T (64-bit x86), Itanium®, and ARM. In the ten months since Pin 2 was released in July 2004, there have been over 3000 downloads from its website.},
  booktitle = {Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {190–200},
  numpages  = {11},
  keywords  = {program analysis tools, dynamic compilation, instrumentation},
  location  = {Chicago, IL, USA},
  series    = {PLDI '05}
}

@inproceedings{angr-firmalice,
  title     = {Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware.},
  author    = {Shoshitaishvili, Yan and Wang, Ruoyu and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {NDSS},
  year      = {2015}
}

@inproceedings{angr-shoshitaishvili2016state,
  title     = {{SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis}},
  author    = {Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and
               Stephens, Nick and Polino, Mario and Dutcher, Audrey and Grosen, John and
               Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {IEEE Symposium on Security and Privacy},
  year      = {2016}
}

@article{redqueen-ndss19,
  title   = {REDQUEEN: Fuzzing with Input-to-State Correspondence},
  author  = {Cornelius Aschermann and Sergej Schumilo and Tim Blazytko and Robert Gawlik and Thorsten Holz},
  journal = {Proceedings 2019 Network and Distributed System Security Symposium},
  year    = {2019}
}

@inproceedings{effective-seed-scheduling-for-fuzzing-with-graph-centrality-analysis,
  author    = {She, Dongdong and Shah, Abhishek and Jana, Suman},
  booktitle = {2022 IEEE Symposium on Security and Privacy (SP)},
  title     = {Effective Seed Scheduling for Fuzzing with Graph Centrality Analysis},
  year      = {2022},
  volume    = {},
  number    = {},
  pages     = {2194-2211},
  doi       = {10.1109/SP46214.2022.9833761}
}


@inproceedings{nyx-hypervisor-fuzzer-usenix21,
  author    = {Sergej Schumilo and Cornelius Aschermann and Ali Abbasi and Simon W{\"o}r-ner and Thorsten Holz},
  title     = {Nyx: Greybox Hypervisor Fuzzing using Fast Snapshots and Affine Types},
  booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
  year      = {2021},
  isbn      = {978-1-939133-24-3},
  pages     = {2597--2614},
  url       = {https://www.usenix.org/conference/usenixsecurity21/presentation/schumilo},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{kafl-usenix17,
  author    = {Sergej Schumilo and Cornelius Aschermann and Robert Gawlik and Sebastian Schinzel and Thorsten Holz},
  title     = {{kAFL}: {Hardware-Assisted} Feedback Fuzzing for {OS} Kernels},
  booktitle = {26th USENIX Security Symposium (USENIX Security 17)},
  year      = {2017},
  isbn      = {978-1-931971-40-9},
  address   = {Vancouver, BC},
  pages     = {167--182},
  url       = {https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/schumilo},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{libafl-ccs21,
  author    = {Fioraldi, Andrea and Maier, Dominik Christian and Zhang, Dongjia and Balzarotti, Davide},
  title     = {LibAFL: A Framework to Build Modular and Reusable Fuzzers},
  year      = {2022},
  isbn      = {9781450394505},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3548606.3560602},
  doi       = {10.1145/3548606.3560602},
  abstract  = {The release of AFL marked an important milestone in the area of software security testing, revitalizing fuzzing as a major research topic and spurring a large number of research studies that attempted to improve and evaluate the different aspects of the fuzzing pipeline.Many of these studies implemented their techniques by forking the AFL codebase. While this choice might seem appropriate at first, combining multiple forks into a single fuzzer requires a high engineering overhead, which hinders progress in the area and prevents fair and objective evaluations of different techniques. The highly fragmented landscape of the fuzzing ecosystem also prevents researchers from combining orthogonal techniques and makes it difficult for end users to adopt new prototype solutions.To tackle this problem, in this paper we propose LibAFL, a framework to build modular and reusable fuzzers. We discuss the different components generally used in fuzzing and map them to an extensible framework. LibAFL allows researchers and engineers to extend the core fuzzer pipeline and share their new components for further evaluations. As part of LibAFL, we integrated techniques from more than 20 previous works and conduct extensive experiments to show the benefit of our framework to combine and evaluate different approaches. We hope this can help to shed light on current advancements in fuzzing and provide a solid base for comparative and extensible research in the future.},
  booktitle = {Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {1051–1065},
  numpages  = {15},
  keywords  = {fuzzing, fuzz testing, framework},
  location  = {Los Angeles, CA, USA},
  series    = {CCS '22}
}

@article{the-art-science-and-engineering-of-fuzzing-a-survey,
  author  = {Manès, Valentin J.M. and Han, HyungSeok and Han, Choongwoo and Cha, Sang Kil and Egele, Manuel and Schwartz, Edward J. and Woo, Maverick},
  journal = {IEEE Transactions on Software Engineering},
  title   = {The Art, Science, and Engineering of Fuzzing: A Survey},
  year    = {2021},
  volume  = {47},
  number  = {11},
  pages   = {2312-2331},
  doi     = {10.1109/TSE.2019.2946563}
}

@inproceedings{gramatron-effective-grammar-aware-fuzzing,
  author    = {Srivastava, Prashast and Payer, Mathias},
  title     = {Gramatron: Effective Grammar-Aware Fuzzing},
  year      = {2021},
  isbn      = {9781450384599},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3460319.3464814},
  doi       = {10.1145/3460319.3464814},
  abstract  = {Fuzzers aware of the input grammar can explore deeper program states using grammar-aware mutations. Existing grammar-aware fuzzers are ineffective at synthesizing complex bug triggers due to: (i) grammars introducing a sampling bias during input generation due to their structure, and (ii) the current mutation operators for parse trees performing localized small-scale changes. Gramatron uses grammar automatons in conjunction with aggressive mutation operators to synthesize complex bug triggers faster. We build grammar automatons to address the sampling bias. It restructures the grammar to allow for unbiased sampling from the input state space. We redesign grammar-aware mutation operators to be more aggressive, i.e., perform large-scale changes. Gramatron can consistently generate complex bug triggers in an efficient manner as compared to using conventional grammars with parse trees. Inputs generated from scratch by Gramatron have higher diversity as they achieve up to 24.2 more coverage relative to existing fuzzers. Gramatron makes input generation 98 faster and the input representations are 24 smaller. Our redesigned mutation operators are 6.4\texttimes{} more aggressive while still being 68 faster at performing these mutations. We evaluate Gramatron across three interpreters with 10 known bugs consisting of three complex bug triggers and seven simple bug triggers against two Nautilus variants. Gramatron finds all the complex bug triggers reliably and faster. For the simple bug triggers, Gramatron outperforms Nautilus four out of seven times. To demonstrate Gramatron’s effectiveness in the wild, we deployed Gramatron on three popular interpreters for a 10-day fuzzing campaign where it discovered 10 new vulnerabilities.},
  booktitle = {Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {244–256},
  numpages  = {13},
  keywords  = {dynamic software analysis, grammar-aware, Fuzzing},
  location  = {Virtual, Denmark},
  series    = {ISSTA 2021}
}

@inproceedings{fuzzy-sat-fuzzing-symbolic-expressions,
  author    = {Borzacchiello, Luca and Coppa, Emilio and Demetrescu, Camil},
  booktitle = {2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)},
  title     = {Fuzzing Symbolic Expressions},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {711-722},
  doi       = {10.1109/ICSE43902.2021.00071}
}

@article{fuzzolic-hybrid-fuzzer,
  author     = {Borzacchiello, Luca and Coppa, Emilio and Demetrescu, Camil},
  title      = {FUZZOLIC: Mixing Fuzzing and Concolic Execution},
  year       = {2021},
  issue_date = {Sep 2021},
  publisher  = {Elsevier Advanced Technology Publications},
  address    = {GBR},
  volume     = {108},
  number     = {C},
  issn       = {0167-4048},
  url        = {https://doi.org/10.1016/j.cose.2021.102368},
  doi        = {10.1016/j.cose.2021.102368},
  journal    = {Comput. Secur.},
  month      = {sep},
  numpages   = {26},
  keywords   = {Fuzzing testing, Hybrid fuzzing, SMT Solver, Concolic execution, Bug detection}
}

@inproceedings{AFLplusplus-Woot20,
  author    = {Andrea Fioraldi and Dominik Maier and Heiko Ei{\ss}feldt and Marc Heuse},
  title     = {{AFL++}: Combining Incremental Steps of Fuzzing Research},
  booktitle = {14th {USENIX} Workshop on Offensive Technologies ({WOOT} 20)},
  year      = {2020},
  publisher = {{USENIX} Association},
  month     = aug
}

@article{a-survey-of-symbolic-execution-techniques,
  author     = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
  title      = {A Survey of Symbolic Execution Techniques},
  year       = {2018},
  issue_date = {May 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {3},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3182657},
  doi        = {10.1145/3182657},
  abstract   = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
  journal    = {ACM Comput. Surv.},
  month      = {may},
  articleno  = {50},
  numpages   = {39},
  keywords   = {software testing, static analysis, Symbolic execution, concolic execution}
}

@article{symqemu-ndss-2021,
  title   = {SymQEMU: Compilation-based symbolic execution for binaries},
  author  = {Sebastian Poeplau and Aur{\'e}lien Francillon},
  journal = {Proceedings 2021 Network and Distributed System Security Symposium},
  year    = {2021}
}

@inproceedings{symcc-usenix-2020,
  author    = {Sebastian Poeplau and Aur{\'e}lien Francillon},
  title     = {Symbolic execution with {SymCC}: Don{\textquoteright}t interpret, compile!},
  booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
  year      = {2020},
  isbn      = {978-1-939133-17-5},
  pages     = {181--198},
  url       = {https://www.usenix.org/conference/usenixsecurity20/presentation/poeplau},
  publisher = {USENIX Association},
  month     = aug
}

@article{sage-acm-2012,
  author     = {Godefroid, Patrice and Levin, Michael Y. and Molnar, David},
  title      = {SAGE: Whitebox Fuzzing for Security Testing: SAGE Has Had a Remarkable Impact at Microsoft.},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {10},
  number     = {1},
  issn       = {1542-7730},
  url        = {https://doi.org/10.1145/2090147.2094081},
  doi        = {10.1145/2090147.2094081},
  abstract   = {Most ACM Queue readers might think of "program verification research" as mostly theoretical with little impact on the world at large. Think again. If you are reading these lines on a PC running some form of Windows (like 93-plus percent of PC users--that is, more than a billion people), then you have been affected by this line of work--without knowing it, which is precisely the way we want it to be.},
  journal    = {Queue},
  month      = {jan},
  pages      = {20–27},
  numpages   = {8}
}

@inproceedings{superion-grammar-fuzzer,
  author    = {Wang, Junjie and Chen, Bihuan and Wei, Lei and Liu, Yang},
  booktitle = {2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)},
  title     = {Superion: Grammar-Aware Greybox Fuzzing},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {724-735},
  doi       = {10.1109/ICSE.2019.00081}
}

@article{nautilus-grammar-fuzzer,
  title   = {NAUTILUS: Fishing for Deep Bugs with Grammars},
  author  = {Cornelius Aschermann and Tommaso Frassetto and Thorsten Holz and Patrick Jauernig and Ahmad-Reza Sadeghi and Daniel Teuchert},
  journal = {Proceedings 2019 Network and Distributed System Security Symposium},
  year    = {2019}
}

@inproceedings{sydr-fuzz-ispras-2022,
  doi       = {10.1109/ispras57371.2022.10076861},
  url       = {https://doi.org/10.1109%2Fispras57371.2022.10076861},
  year      = 2022,
  month     = {dec},
  publisher = {{IEEE}
               },
  author    = {Alexey Vishnyakov and Daniil Kuts and Vlada Logunova and Darya Parygina and Eli Kobrin and Georgy Savidov and Andrey Fedotov},
  title     = {Sydr-Fuzz: Continuous Hybrid Fuzzing and Dynamic Analysis for Security Development Lifecycle},
  booktitle = {2022 Ivannikov Ispras Open Conference ({ISPRAS})}
}

@misc{sydr-cutting-edge-dynamic-symbolic-execution,
  title     = {Sydr: Cutting Edge Dynamic Symbolic Execution},
  url       = {http://dx.doi.org/10.1109/ISPRAS51486.2020.00014},
  doi       = {10.1109/ispras51486.2020.00014},
  journal   = {2020 Ivannikov Ispras Open Conference (ISPRAS)},
  publisher = {IEEE},
  author    = {Vishnyakov, Alexey and Fedotov, Andrey and Kuts, Daniil and Novikov, Alexander and Parygina, Darya and Kobrin, Eli and Logunova, Vlada and Belecky, Pavel and Kurmangaleev, Shamil},
  year      = {2020},
  month     = {Dec}
}

@misc{symbolic-security-predicates,
  title     = {Symbolic Security Predicates: Hunt Program Weaknesses},
  url       = {http://dx.doi.org/10.1109/ISPRAS53967.2021.00016},
  doi       = {10.1109/ispras53967.2021.00016},
  journal   = {2021 Ivannikov Ispras Open Conference (ISPRAS)},
  publisher = {IEEE},
  author    = {Vishnyakov, Alexey and Logunova, Vlada and Kobrin, Eli and Kuts, Daniil and Parygina, Darya and Fedotov, Andrey},
  year      = {2021},
  month     = {Dec}
}

@inproceedings{address-sanitizer-usenix-2012,
  title     = {AddressSanitizer: A Fast Address Sanity Checker},
  author    = {Kostya Serebryany and Derek Bruening and Alexander Potapenko and Dmitriy Vyukov},
  booktitle = {USENIX Annual Technical Conference},
  year      = {2012}
}

@misc{symbolic-pointers-reasoning,
  title     = {Towards Symbolic Pointers Reasoning in Dynamic Symbolic Execution},
  url       = {http://dx.doi.org/10.1109/IVMEM53963.2021.00014},
  doi       = {10.1109/ivmem53963.2021.00014},
  journal   = {2021 Ivannikov Memorial Workshop (IVMEM)},
  publisher = {IEEE},
  author    = {Kuts, Daniil},
  year      = {2021},
  month     = {Sep}
}

@misc{fuzzing-a-survey-2018,
  title     = {Fuzzing: a survey},
  volume    = {1},
  url       = {http://dx.doi.org/10.1186/s42400-018-0002-y},
  doi       = {10.1186/s42400-018-0002-y},
  number    = {1},
  journal   = {Cybersecurity},
  publisher = {Springer Science and Business Media LLC},
  author    = {Li, Jun and Zhao, Bodong and Zhang, Chao},
  year      = {2018},
  month     = {Jun},
  language  = {en}
}

@inproceedings{fuzzbench-2021,
  author    = {Metzman, Jonathan and Szekeres, L\'{a}szl\'{o} and Maurice Romain Simon, Laurent and Trevelin Sprabery, Read and Arya, Abhishek},
  title     = {{FuzzBench: An Open Fuzzer Benchmarking Platform and Service}},
  year      = {2021},
  isbn      = {9781450385626},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3468264.3473932},
  doi       = {10.1145/3468264.3473932},
  booktitle = {Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages     = {1393–1403},
  numpages  = {11},
  series    = {ESEC/FSE 2021}
}

@inproceedings{z3-smt-solver,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}

@article{bitwuza-smt-comp-2020,
  author        = {Aina Niemetz and
                   Mathias Preiner},
  title         = {Bitwuzla at the {SMT-COMP} 2020},
  journal       = {CoRR},
  volume        = {abs/2006.01621},
  year          = {2020},
  url           = {https://arxiv.org/abs/2006.01621},
  archiveprefix = {arXiv},
  eprint        = {2006.01621},
  biburl        = {https://dblp.org/rec/journals/corr/abs-2006-01621.bib},
  bibsource     = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{cvc5-smt-solver,
  author    = {Barbosa, Haniel
               and Barrett, Clark
               and Brain, Martin
               and Kremer, Gereon
               and Lachnitt, Hanna
               and Mann, Makai
               and Mohamed, Abdalrhman
               and Mohamed, Mudathir
               and Niemetz, Aina
               and N{\"o}tzli, Andres
               and Ozdemir, Alex
               and Preiner, Mathias
               and Reynolds, Andrew
               and Sheng, Ying
               and Tinelli, Cesare
               and Zohar, Yoni},
  editor    = {Fisman, Dana
               and Rosu, Grigore},
  title     = {cvc5: A Versatile and Industrial-Strength SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2022},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {415--442},
  abstract  = {cvc5 is the latest SMT solver in the cooperating validity checker series and builds on the successful code base of CVC4. This paper serves as a comprehensive system description of cvc5 's architectural design and highlights the major features and components introduced since CVC4  1.8. We evaluate cvc5 's performance on all benchmarks in SMT-LIB and provide a comparison against CVC4 and Z3.},
  isbn      = {978-3-030-99524-9}
}

@inproceedings{KLEE-OSDI-2008,
  author    = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson R.},
  biburl    = {https://www.bibsonomy.org/bibtex/2f23cc082a4d350585f4b0e8c8d4d5c9c/dblp},
  booktitle = {OSDI},
  editor    = {Draves, Richard and van Renesse, Robbert},
  ee        = {http://www.usenix.org/events/osdi08/tech/full_papers/cadar/cadar.pdf},
  isbn      = {978-1-931971-65-2},
  keywords  = {dblp},
  pages     = {209-224},
  publisher = {USENIX Association},
  timestamp = {2020-03-13T12:42:02.000+0100},
  title     = {KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs.},
  url       = {http://dblp.uni-trier.de/db/conf/osdi/osdi2008.html#CadarDE08},
  year      = 2008
}

@article{cyclomatic-complexity-density,
  author  = {Gill, G.K. and Kemerer, C.F.},
  journal = {IEEE Transactions on Software Engineering},
  title   = {Cyclomatic complexity density and software maintenance productivity},
  year    = {1991},
  volume  = {17},
  number  = {12},
  pages   = {1284-1288},
  doi     = {10.1109/32.106988}
}

@inproceedings{libfuzzer-secdev-2016,
  author    = {Serebryany, Kosta},
  booktitle = {2016 IEEE Cybersecurity Development (SecDev)},
  title     = {Continuous Fuzzing with libFuzzer and AddressSanitizer},
  year      = {2016},
  volume    = {},
  number    = {},
  pages     = {157-157},
  doi       = {10.1109/SecDev.2016.043}
}

@inproceedings{diffuzz-icse-2018,
  doi       = {10.1145/3236024.3264835},
  url       = {https://doi.org/10.1145%2F3236024.3264835},
  year      = 2018,
  month     = {oct},
  publisher = {{ACM}
               },
  author    = {Jianmin Guo and Yu Jiang and Yue Zhao and Quan Chen and Jiaguang Sun},
  title     = {{DLFuzz}: differential fuzzing testing of deep learning systems},
  booktitle = {Proceedings of the 2018 26th {ACM} Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering}
}

@inproceedings{casr-cluster-ispras-2021,
  author    = {Savidov, Georgy and Fedotov, Andrey},
  booktitle = {2021 Ivannikov Ispras Open Conference (ISPRAS)},
  title     = {Casr-Cluster: Crash Clustering for Linux Applications},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {47-51},
  doi       = {10.1109/ISPRAS53967.2021.00012}
}