\documentclass[conference]{IEEEtran}

\usepackage[pdftex]{graphicx}
\graphicspath{{./assets}{../jpeg/}}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}

\usepackage[cmex10]{amsmath}
\usepackage{mathabx}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
\usepackage{eqparbox}
\usepackage{url}
\usepackage{tikz}
\usepackage{listings}
\usepackage{lstfiracode}
\usepackage{xcolor}

\lstset{basicstyle=\ttfamily}
\begin{document}

\title{Utilizing debug information to improve error-finding methods in the context of hybrid fuzzing}

\author{
    \IEEEauthorblockN{
        Larionov-Trichkine Theodor Arsenij
    }
    \IEEEauthorblockA{
        Information Security\\National Research University "Higher School of Economics"\\Moscow, Russia
    }
    tlarionovtrishkin@edu.hse.ru
}

\maketitle

\begin{abstract}
    The use of fuzzing as a technique for identifying software vulnerabilities has become increasingly popular in recent years. While traditional fuzzing methods can be effective, they are inherently limited in their ability to find certain types of errors.

    Hybrid fuzzing tries to overcome these limitations by leveraging the power of symbolic execution to generate inputs that can explore different paths in a program. However, the effectiveness of hybrid fuzzing can be hindered by imprecise boundaries calculations for symbolic memory accesses. This research project aims to address this issue by utilizing debug information to improve error-finding methods in the context of hybrid fuzzing.

    The core idea of the project is to enhance the calculation of boundaries for symbolic memory accesses by leveraging debug information. With more accurate boundaries, local out-of-bounds bugs can be identified, and overall performance can be improved. The research will explore the feasibility of using debug information for boundaries calculation in the context of hybrid fuzzing and evaluate its effectiveness.

    The project's methodology will involve implementing and testing the proposed approach on several open-source software projects. The results of this research will provide insights into the potential of using debug information to enhance hybrid fuzzing and could pave the way for more effective techniques in identifying software vulnerabilities.
\end{abstract}

\IEEEoverridecommandlockouts
\begin{IEEEkeywords}
    Hybrid fuzzing, symbolic execution, symbolic pointers, symbolic addresses, symbolic memory model, debug information, error-finding, software security testing.
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle


% ===================
% # I. Introduction #
% ===================

\section{Introduction}
With the rapid development of information technologies, the number and complexity of software systems have increased drastically. This has led to an increase in the number of software vulnerabilities as well as an increasing need for secure software development practices.

One area of concern in software security is memory safety, particularly in the context of programming languages. Memory-unsafe languages, such as C and C++, are known to impose significant vulnerabilities due to their low-level nature and lack of automatic memory management \cite{chromium-project-memory-safety, android-project-memory-safety}. These vulnerabilities can range from buffer overflows to use-after-frees and beyond, and often lead to full system compromise.

In order to address these issues, a variety of techniques have been developed, including static and dynamic analysis. While static analysis is a powerful tool for identifying vulnerabilities, it has its limitations. To complement static analysis and improve the overall effectiveness of vulnerability detection, dynamic analysis techniques emerged.

Dynamic analysis often referred to as fuzzing, involves an automated generation of input data to test the behavior of a program at runtime.

The field of fuzzing has been actively developing for years, and nowadays, there is a variety of fuzzing techniques and tools available:

\begin{itemize}
    \item AFL++~\cite{AFLplusplus-Woot20} is a popular fuzzing tool that uses a genetic algorithm and coverage feedback to generate new inputs.
    \item Superion~\cite{superion-grammar-fuzzer} and Nautilus~\cite{nautilus-grammar-fuzzer} are grammar-based fuzzers that use hand-crafted grammar to generate inputs with a specific structure.
    \item Sydr~\cite{sydr-cutting-edge-dynamic-symbolic-execution} and Fuzzolic~\cite{fuzzolic-hybrid-fuzzer} are examples of hybrid fuzzers that combine the power of symbolic execution with the speed of fuzzing.
\end{itemize}

All approaches are feasible, however, some of them require additional resources and time. That's where hybrid fuzzing shines. By using symbolic execution, it can generate structurally correct inputs that can explore different paths in a program without requiring any additional effort from the user.

Consider the following example:

\begin{lstlisting}[caption={Example solvable by hybrid fuzzing},label={lst:example1},language=C, basicstyle=\small\ttfamily, numbers=left, xleftmargin=2em, breaklines=true, captionpos=b]
void vuln(int key) {
    if (key * 0x142a2d == 0xdeadbeef) {
        error();
    }
}
\end{lstlisting}


With traditional fuzzing, it is almost impossible to randomly generate an input that will trigger the error in example \ref{lst:example1}. However, hybrid fuzzing methods allow us to generate a crash input by building a symbolic expression that represents the original input and then solving the constraints. This approach helps to overcome the limitations of traditional fuzzing and can be used to find a variety of bugs.

A hybrid fuzzing tool that I'm going to work with in this research is Sydr~\cite{sydr-cutting-edge-dynamic-symbolic-execution}. Sydr is a dynamic symbolic execution engine based on Triton~\cite{saudel15} that is used to solve the programs' constraints and generate inputs that can explore new program states. Besides the ability to generate new inputs, Sydr also uses a novel technique called {"Security Predicates"}~\cite{symbolic-security-predicates} to purposefully trigger error conditions in a program under test.

Sydr has a lot of features, and one of the most interesting ones is the ability to handle symbolic memory accesses, which in itself is a very complex task \cite{symbolic-pointers-reasoning}. This feature allows Sydr to model symbolic memory accesses and, as such, greatly improve the effectiveness of hybrid fuzzing. However, the current implementation of symbolic pointers is not perfect. Boundaries calculations for symbolic memory accesses are imprecise, which can lead to incorrect results and hinder the effectiveness of hybrid fuzzing.

The goal of this research project is to improve the calculation of boundaries for symbolic memory accesses by leveraging debug information. Debug information allows to find precise boundaries for a lot of different types of memory accesses. For example, it can be used to find the exact size of local and global variables or heap objects. With more accurate boundaries, a few aspects of the Sydr can be improved:

\begin{itemize}
    \item The effectiveness of Security Predicates because, with more accurate boundaries, more types of bugs can be found (e.g. local out-of-bounds bugs).
    \item The overall speed and accuracy, because smaller memory regions put less strain on an SMT-solver.
\end{itemize}

% In addition to that, support for symbolic pointers allows Sydr to detect some out-of-bounds bugs. 

% =========================
% # II. Literature review #
% =========================

\section{Literature review}


% ================
% # III. Methods #
% ================

\section{Methods}

% ===========================
% # IV. Results anticipated #
% ===========================

\section{Anticipated results}

% ==================
% # V. CONCLUSION #
% ==================

\section{Conclusion}

The software security field is constantly evolving, being in a state of race between security researchers and hackers.

% ==================
% # ACKNOWLEDGMENTS #
% ==================

% use section* for acknowledgement
%\section*{Acknowledgment}
% The authors would like to thank...


% ==============
% # REFERENCES #
% ==============

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,bibliography}

\end{document}
